---
title: java学习笔记
Date: 2023-09-09
tags:
  - 面试
  - 考试
author: Gavin
---

## 1.谈谈你对spring的理解以及与springboot和 springmvc区别
<mark style="background: #FFB8EBA6;">spring是一个开源的框架,为简化基业级应用而生</mark>,spring可以使得简单的javaBean实现以前只有EJB才能实现的功能,spring是一个IOC和AOP容器框架

spring的主要的核心是:
### 控制翻转IOC   Inversion of Control
实现原理: 反射和工厂模式
在IOC模式下,控制权发生了翻转,即从应用程序转移到了IOC容器,所有的组件不再由应用程序自己创建和配置,而是由IOC容器负责,这样应用程序只需要直接使用已经创建好并且配置好的组件,它解决了一个最主要的问题,将组件的创建+配置于组件的使用分离,并且,由IOC容器负责管理组件的生命周期

### 依赖注入DI    dependencies injection
可以通过set方法注入,也可以通过构造器的方式注入
spring通过javaBean对象的set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置为所需要的值的过程就是依赖注入的思想
### 面向切面编程AOP   Aspect oriented programm
在面向对象编程的思想中,我们将事务纵向抽象成一个个的对象,而在面向切面编程的思想中,我们将一个个对象的某些类似的方面横向抽象成一个个切面,对这个切面进行一些比如权限控制,事务管理,记录日志等公用操作处理的过程就是面向切面编程的思想,AOP的底层是动态代理,如果是接口采用JDK的动态代理,如果是类采用CGLIB的方式实现动态代理

### springBoot和springMVC的区别
#峰哥的答案
1.简化依赖: springboot拥有各种的启动器,包含了大量的依赖包,可以简化依赖的关系,快速的进行应用的开发
2.自动配置: 通过各种的starter可以快速的集成功能到我们自己的项目中
![](imgs/Pasted%20image%2020230912105710.png)

---

springboot简化了企业应用的开发,提供了开箱即用的功能,可以快速的构建项目

而springMVC是一个表述层的框架,是spring项目的子模块,依赖于springIOC容器,主要的作用是解决请求响应的问题
m: model 对应的java中的实体bean
v: view 对应的是视图
c: 指的是controller控制器

springMVC相当于一辆手动挡的汽车,springBoot相当于把汽车编程了自动当,还加装了无钥匙进入,自动启停等功能,可以让开车更省心,但是车的主体的功能没有变化

---
SpringMVC属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；

SpringBoot框架相对于SpringMVC框架来说，更专注于开发微服务后台接口，不开发前端视图；
## 2.项目中使用springCloud组件的场景有哪些？起到了什么作用？
### 注册中心: nacos Eureka zookeeper  
服务的注册和发现,保存某个服务所在的地址信息,方便调用者实时获取其他服务信息
### 配置中心: nacos config zookeeper   
系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。
### 远程调用组件: OpenFeign Feign 
可以实现跨服务调用方法

Feign是一个声明式的web服务客户端,让编写web服务客户端变得非常的容易,但是不支持springMVC的注解,springCloud对Feign进行了封装,使其支持了springMVC标准注解和HttpMessageConverters,Feign可以和Eureka和Ribbon组合使用以支持负载均衡

基于springMVC注解 + JDK代理 + Http客户端实现的,集成了ribbon以及Hystrix还有http的客户端
1.通过@FeignCLient注解定义一个接口类,并指定服务信息和降级类
2.通过springMVC的一套注解定义接口方法
3.基于JDK代理生成代理对象
4.代理对象通过HttpClient发送请求到服务的提供方
5.获取服务提供方的响应结果并把响应结果封装成java对象
### 网关组件: Gateway
提供了断言,过滤,路由的功能
1.可以根据断言(predicates)规则匹配不同的路由,把请求路由到不同的服务
2.可以通过过滤器链对请求进一步的过滤或者其他的处理
3.根据URL规则进入对应的服务最终处理请求并响应结果
### 链路追踪: sleuth (zipkin)
分布式链路追踪组件
监控每个请求的链路的信息(服务,接口是否正常的执行),每个接口的执行时间,基于链路追踪数据,发现异常点为限流做数据的支撑
### 负载均衡: ribbon
负载均衡：将用户的请求平均分配到多个服务器上，从而达到系统的HA(高可用)。
基于Rabbion做的负载均衡: 轮询,随机,一致性算法,hash
### 熔断降级: hystrix  sentinel
某个服务频繁超时,直接将其短路,快速返回mock值
### 限流组件: sentinel
分布式的限流熔断降级的组件
两个概念: 资源(主要是方法和服务),规则(限流规则,降级规则,系统规则)
作用: 流量控制,熔断降级,系统负载保护

限制其他的服务调用某一个服务的频率
## 3.简述http与https区别  
1.连接方式不同
http的连接是无状态的,不安全
https协议是由SSL+HTTP协议构建的加密传输,身份认证的网络协议,比http协议安全

2.端口不同
http默认的端口是80
https默认的端口是443

3.加密的机制不同
http通信过程中的数据是明文传输
https在http的基础上加入SSL层,所有的数据以加密形式传输

4.识别方式不同
http的url以http://开头
https的url以https://开头

5.证书验证
https要求客户端对服务器提供的证书进行验证,验证通过后才能建立加密通信通道

6.技术消耗
https需要进行额外的加密解密的过程,所以行笔于http的性能略差,但是随着技术发展性能的差距正在缩小

7.成本不同
https的部署比http复杂,需要证书,维护工作量大,因此成本更高

8.可靠性不同
https的协议的数据传输较HTTP更可靠,可以抵御中间人的攻击

总体来说,http适用于对安全性要求不高的场景,https使用于对安全性要求更高的场景,如银行,交易等,提供更为可靠的身份验证和数据加密传输
## 4.常见的垃圾回收算法有哪些(4个)和垃圾回收器有哪些(7个) 
### 垃圾判定的算法(2个)
#### 引用技术法:
通过判断对象的引用数量来决定对象是否可以被回收,每当有地方引用这个对象的时候,计数器就+1,引用失效的时候计数器就-1

简单高效,但是引用和去引用伴随这加减法,影响性能
很难处理循环引用,相互引用的两个对象无法释放

#问题 
互相引用以及环形的引用没有办法释放,可能会造成内存泄露
#### 可达性算法(根搜索算法)
将GC Roots作为初始的存活对象集合,然后从该集合触发,探索所有能够被该集合引用到的对象,并将其加入到该集合中,这个过程称之为标记,最终,未被探索到的对象表示死亡的,是可以回收的,真正标记对象为可回收状态至少要标记两次

可以作为GC Roots的对象包含下面几种:
虚拟机栈(栈帧中的本地变量表)中的引用的对象
方法区中的常量引用的对象,静态引用对象
本地方法栈中JNI(Native方法)的引用的对象
锁中的对象

### 垃圾回收算法(4个)
#### 复制算法
将内存平均分成两部分,然后每次只使用其中的一部分,当着部分内存满的时候,将内存中的所有存活的对象复制到另一个内存中,然后将之前的内存清空,只使用这部分内存,循环下去

实现简单,不会产生内存碎片
但是将内存缩小为原来的一半,浪费了一半的内存
如果对象的存活率很高的话,那么将所有的对象都复制一边,并将所有的引用地址重置一遍,耗时耗力

对象存活率越高,清理的效率越低
对象存活率越低,清理的算法越高

#### 标记清除
1.标记出需要回收的对象,使用的标记算法均为可达性分析算法
2.回收被标记的对象

效率问题(每个对象需要标记两次)
空间问题: 标记清除后会产生大量的不连续的碎片,JVM需要维持一个内存的空闲列表
#### 标记压缩(标记整理)
最慢的一种垃圾清理算法,但是好处是不会产生内存碎片

标记清除的改进版本,在标记的阶段,该算法将所有的对象标记为存活和死亡两种状态,不同的是在第二个阶段,概算法并没有直接对死亡的对象进行清理,而是通过将所有存活的对象都向一端移动,然后直接清除边界以外的内存

不仅可以弥补标记/清除算法当中内存区域分散的缺点,夜宵出了复制当中,内存减半的高额代价

#### 分代收集算法
属于复制算法和标记整理算法的结合,根据不同的区域(新生代和老年代)执行不同的算法

结合了复制算法的效率,和整理/标记算法的节省内存
### 垃圾回收器(7个)
垃圾回收器是垃圾回收算法的实现
串行的意思是和用户的请求相比只有一方能运行

| 垃圾回收器名称 | 使用的算法 | 作用区域 | 串行/并行 | 是否STW | 单线程/多线程 | 备注 |
|:-----------|:--------------|:--------|:----------|:------|:--------|:-----------------|
| Serial | 复制算法 | 新生代 | 串行 | 是 | 单线程 | CLIENT模式下的小型应用 |
| Serial Old | 标记-整理算法 | 老年代 | 串行 | 是 | 单线程 | Serial的老年代版本 |  
| ParNew | 复制算法 | 新生代 | 并行 | 是 | 多线程 | 多核CPU服务器的首选 |
| Parallel Scavenge | 复制算法 | 新生代 | 并行 | 是 | 多线程 | 不需要记号整理 |
| Parallel Old | 标记-整理算法 | 老年代 | 并行 | 是 | 多线程 | Parallel Scavenge的老年代版本 |
| CMS | 标记-清除算法 | 老年代 | 并发 | 否 | 多线程 | 互联网场景,注重响应速度 |  
| G1 | 标记-整理算法 | 新生代 + 老年代 | 并发 | 可控 | 多线程 | 面向服务端,可控制停顿 |
| ZGC | 并发标记 + 压缩 | 新生代 + 老年代 | 并发 | 可控(1ms) | 多线程 | 低延迟,面向极大内存容量 |
CMS的清理的过程: (Concurrent Mark Sweep) 并发标记回收
牺牲吞吐量换取低停顿的垃圾回收器
优点: 性能比较的高,停顿时间短
缺点: 
1.由于使用的是标记清除的垃圾回收算法,所以会产生大量的内存碎片,可以配置经过几次标记清除之后进行一次标记整理
2.垃圾回收过程中会降低系统的吞吐量

初始标记(STW): 只标记可以被GCRoots直达的标记
并发标记: 标记出所有的对象
最终标记: STW 很快
并发清除: 运行的过程中执行清除的操作

G1的垃圾清理的过程: 
堆不在是一个连续的内存空间,分成了大小相同的region区
E: eden
S: survivor
O: old
H: humorous 通常是几个region合并成一个H区域
1024
巨型区域: region的合并的结果
特点: 
1.微观来看使用的是复制算法,宏观来看是标记整理的垃圾回收的算法,不会产生内存碎片
2.可预测停顿时间的垃圾回收  Remember Set
## 5.内存泄漏与内存溢出有什么区别 
### 原因不同
内存泄露: 指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放,造成了内存的浪费
内存溢出: 是指程序运行需要的内存超过了系统所能提供的内存数量
### 后果不同
内存泄露: 内存泄露的情况下,内存不会被回收,并不会导致直接的异常,但是会加重GC的压力,导致系统整体缓慢
内存溢出将抛出OutOfMemoryError异常,程序无法继续运行
### 检测不同
内存泄露需要通过工具监视堆内存的使用情况,发现持续增长来定位
内存溢出可以通过异常堆栈定位
### 解决方式不同
内存泄露需要找到泄露的对象,并及时的释放
内存溢出需要调优降低内存使用量,或增加更多的可用的内存

总之,内存泄露是内存使用的抵消,内存溢出是超出内存限制,内存泄露终将导致内存溢出,要解决这两个问题,需要堆内存进行细致的监控和分析
## 6.缓存加入后的数据访问流程  
![缓存加入后的数据访问流程](https://srb-file-230309-gavin-2.oss-cn-shanghai.aliyuncs.com/数据访问流程-王小广/2023/09/08/1694185313361_b99c40.jpg)
首先查询缓存中是否有数据,如果有数据,则直接返回数据
如果没有数据,查询布隆过滤器里面是否有该key,如果没有这个key,返回null
如果有这个key,获取分布式锁,再次查询缓存中是否有数据,如果有数据,返回数据
如果缓存中还是没有数据,则去MySQL里面查询对应的数据,并将数据存入Redis缓存中
解锁
返回数据
## 7.分别介绍缓存击穿 缓存 穿透 雪崩是什么？分别是如何解决的？  
缓存击穿:
某一个热点key失效了,然后所有的请求在缓存中查询不到对应的数据,转向到MySQL中查询数据,导致MySQL扛不住大量的并发请求从而宕机
解决方法: 通过分布式锁的方式避免大量的请求同时访问MySQL

缓存穿透:
查询的某一个key在Redis中没有数据,进而转向到MySQL中查询数据,缓存失去了作用
解决方法: 将查询不存在的null值也进行缓存,还可以通过布隆过滤器来判断是否包含这个key,如果含有这个key则放行,如果不包含这个key则直接返回null

缓存雪崩: 
在同一时间,大量的key同时失效,导致大量的请求同时访问MySQL
解决方法: 在给key设置过期时间的时候,可以再给时间加上一个随机值,避免同时的失效
## 8.分别从单表 关联 子查询分组排序等角度阐述优化SQL语句  
### 单表查询优化
1. 不在索引列上做任何的计算(计算,函数,自动或手动的类型转换),因为会导致索引失效而转向全表扫描
2. like以通配符开头会导致索引失效
3. 使用不等于(!= <>)的时候也会导致索引失效
4. is not null 也会导致索引失效,但是is null不会导致索引失效
5. 字符串不加单引号索引也会失效
### 组合索引
创建复合索引时,优先框可能使用范围/不等于/模糊查询的列放在最后,or不管放到哪个位置都会导致复合索引失效

1. 复合索引比单值索引性价比高
2. 复合索引需要满足最左原则
3. 不能跳过中间的列
4. 复合索引的第一个使用了不等于/范围查询会导致整个索引失效
5. 复合索引非第一个列使用不等于/范围查询会导致它的右边的索引失效
6. 模糊查询会导致当前字段和它右边的索引失效
7. 第一个字段如果使用了单个字段导致索引失效的写法,整个复合索引也会失效
### 联合查询的优化
1.小表驱动大表,被驱动表的连接字段创建索引
2.能使用联合查询的就不要使用子查询
3.子查询尽量不要放在被驱动表,有可能使用不到索引

如果是外连接,那么谁先查询谁就是驱动表
如果是内连接,那么小表就是驱动表,大表就是被驱动表
### 子查询的优化
不要使用not in 和 not exist
不要使用子查询
### 排序查询的优化
无过滤,不索引: order by的字段如果有创建索引,那么需要结合limit或者where条件的字段+排序字段组成复合索引使用,才可以走索引

顺序错,不索引: where条件+order by的多个字段的复合索引,使用是依顺序和索引结构不一致导致索引失效

方向反,不索引:
排序用到的多个字段,如果和复合索引的顺序一样,但是排序的方向反了,也会导致索引失效
### 分组排序优化
基本上和排序优化一样,但是不需要过滤就可以使用索引
只需要对分组的列创建索引就行,但是需要根据实际的情况来看是否需要创建索引,因为有可能使用了索引之后查询的时间反而还变长了

## 9.聚簇索引和非聚簇索引有区别？什么是回表？  
聚簇索引的叶子节点存储数据项(主键ID) + 行数据
非聚簇索引的叶子节点存储数据项 + 主键值

回表查询: 
第一次查询只能获取到主键的值,需要回表到聚簇索引中查询行记录

区别3: 
InnoDB支持聚簇索引 MyIsam不支持聚簇索引

区别4:
聚簇索引只能有一个,但是非聚簇索引可以有多个
## 10.简述MVCC的底层原理？在事务隔离级别中如何体现的？  
MVCC multiple version concurrent Control
多版本并发控制
MVCC的底层的实现是通过 隐藏字段 + undoLog + readView来实现的
隐藏字段: trx_id事务的id   roll_pointer 回滚指针,指向的是上一个版本的数据 row_id隐藏的主键,如果数据表没有设置主键的话,那么会生成一个6字节的row_id作为隐藏的主键
undoLog: 回滚日志
readView: 读视图   事务在进行快照读的时候产生的读视图,保存的并不是数据的信息,而是事务的相关的信息
两个概念: 快照读和当前读
只有select的操作会触发快照读

可见性算法: 
readview里面包含这么几个字段 
creator_trx_id 当前事务的id
up_limit_id 活跃事务id列表中最小的事务的id
trx_ids 活跃事务id列表
low_limt_id 系统中即将要分配的下一个事务的id

首先判断trx_id是否和creator_id相等,如果相等说明当前版本日志属于当前的事务,可以读取

如果不相等,在判断 trx_id 是否小于 up_limit_id ,如果小于则说明属于历史事务数据,当前的事务是可以读的

如果up_limit_id <= trx_id < low_limit_id 那么需要判断trx_id是否在活跃事务的列表中:
如果在,那么说明当前的事务产生readview的时候,该事务还没有提交,当前的事务不可读,需要通过版本链找上一个版本,从头开始重新判断
如果不在,则说明当前的事务产生readview的时候,该事务已经提交了,当前的事务可读

如果trx_id >= low_limit_id,说明当前的事务的readview产生的时候,该事务还未存在,则到当前事务不可读,需要通过版本链找上一个版本, 从头开始重新判断

RU 读未提交
RC 读已提交
RR 可重复读

关系型数据库隔离级别
RU: read uncommited 
快照读读取最新的版本即可

RC: read commited 
事务每次读取的时候生成一个ReadView

RR: read repeatable
事务在第一次读取数据时,生成一个ReadView,以后的查询都使用该ReadView
同时也可以解决幻读的问题

SR: 加锁
## 11.谈谈你对面向对象的理解？  
封装: 
将数据和操作数据的方法绑定起来,对数据的访问只能通过已定义的接口
<mark style="background: #FFB8EBA6;">数据被保护在类的内部,尽可能地隐藏内部的实现细节,只保留一些对外接口使之与外部发生联系</mark>
低耦合,高内聚,可以对成员进行更精确的控制,隐藏信息,实现细节


继承: 继承是从已有类得到继承信息创建新类的过程
子类继承父类的属性和方法,是的子类对象具有父类的属性和方法,或子类从父类继承方法,使得子类具有父类相同的方法
提高了代码的复用性和维护性,让类与类之间产生了关系

<mark style="background: #FFB8EBA6;">子类可以通过继承获取父类的属性和方法,并且可以做出自己的改变或者拓展,好处就是减少代码的冗余,提高代码的复用性</mark>

多态: 
<mark style="background: #FFB8EBA6;">父类引用指向子类对象,由同一个类创建出来的对象,不同的子类对象调用相同的方法,会有不同的结果,这是因为子类重写了父类里面的方法(编译看左边,运行看右边)</mark>
## 12.Java中接口与抽象类有什么区别？  
1.抽象类要被子类继承,接口需要被实现
2.接口可以多继承接口,但是抽象类只能单继承
3.抽象类可以有构造器,接口不能有构造器
4.抽象类: 除了不能实例化抽象类之外,它和普通的java类没有任何的区别
5.抽象类: 抽象方法可以有public protected 和 default这些修饰符,接口的修饰符只能是public
6.抽象类: 可以有成员变量; 接口: 只能声明常量
## 13.你接触到的集合类有哪些？聊聊各自的特点  
[34_集合框架](02%20Java/01JavaSe/34_集合框架.md#Collection和Map)
### colleciton接口
存储的是当个的数据

#### List接口
存储的数据有序,允许重复
ArrayList 可变数组  特点: 查询快,增删慢   线程不安全,但是性能高
LinkedList: 双向链表结构  特点: 增删快,查询慢   
Vector: 和ArrayList类型   所有的方法都使用了synchronized关键字加锁,线程安全,但是性能不高,适用于大量写入的操作
synchronizedList: 可以将ArrayList变成一个线程安全的集合,基本上所有的方法内部都使用同步代码块加锁,除了迭代器相关的方法,使用了装饰者模式,实现了List接口,但是调用它的方法的时候,内部通过传入的list对象来执行返回结果
#### set接口
存储的数据无序,不允许重复
HashSet 石笋的哈希表结构的set集合
TreeSet: 使用的二叉树结构的set集合
LinkedHashSet: 链表+哈希表结构的set集合
### Map接口
存储的是成对的数据
HashMap:      无序,key可以为null  线程不安全
TreeMap:        有序,key不能为null  线程不安全
LinkedHashMap:        有序,key可以为null,是hashmap的子类,线程不安全
HashTable: 线程不安全  
synchronizedMap: 除了迭代器以外所有的方法都使用了同步代码快加锁
[06_JUC_锁,线程,线程池](02%20Java/10高级/06_JUC_锁,线程,线程池.md#ConcurrentHashMap)
ConcurrentHashMap: 线程安全,性能也比较的高,用的最多
当前并发操作同一个索引元素的线程才有竞争的关系,需要争抢锁,如果并发操作的不是同一个索引位置的元素,那么就不会加锁

分segment加锁: put方法中,当保存k-v的位置有元素时,使用了synchronized同步代码对该位置顶点的元素加锁,如果没有元素,则使用原子性操作将元素put到该位置
![](imgs/Pasted%20image%2020230910195925.png)
## 14.简述反射原理？ 
### 反射机制
所谓的反射机制就是java语言在运行时拥有一项自观的能力,通过这种能力可以彻底了解自身的情况为下一步的动作做准备
java的反射机制的实现要借助4个类: class, constructor, Field, Method
其中class代表的是类对象
Constructor代表类的构造器对象
Field 类的属性对象
Method 类的方法对象
通过这四个对象我们可以粗略的看到一个类的各个组成部分
### 反射的作用
在java运行时环境,对于任意一个类,可以知道这个类有哪些属性和方法,对于任一个对象,可以调用它的任意一个方法,这种动态的获取类的信息以及动态调用对象的方法的功能就是java语言的反射机制
### java反射机制提供的功能
在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法
在运行时调用任意一个对象的方法



1. JVM在执行Java程序的时候会把类加载到内存中,每个类都会生成一个对应的Class对象,包含了该类的所有信息。
2. 通过Class对象可以获取类中的所有信息,如构造器、方法、字段等。
3. 通过Class对象可以创建该类的对象,调用该类的方法。
4. 通过反射API像Class、Field、Method等可以动态获取类结构信息、创建对象、调用方法等,这就是Java反射机制的基本原理。

## 15. == 和equals有什么区别？  
1 ==
如果比较的基本的数据类型,那么比较的就是变量的值
如果比较的是引用数据类型,那么比较的是地址值(两个对象是否指向同一块内存)
2 equals
如果没重写equals方法,那么比较的是两个对象的地址值
如果重写了equals方法,我们往往比较的是对象中的属性的内容

equals方法是从object类中继承的,默认的实现就是使用 ==
## 16.列举至少5个的异常信息(空指针除外中英文都行) 
### 运行时异常
编译可以通过,但是运行时如果有问题,会报错
ArrayIndexOutOfBoundsException
NullPointerException
ClassCastException
NumberFormatException
ArithmeticException
### 编译时异常
ClassNotFoundException
IoException
FileNotFountException

## 17.异步编排常用API有哪些(异步任务的创建和编排)  
1.初始化方法
runAsync
supplyAsync
2.计算完成时方法
whenComplete(Async)
exceptionally
3.串行化方法
thenApply(Async)
thenAccept(Async)
thenRun(Async)
4.组合方法
allOf
anyOf
## 18.AQS是什么?由哪些部分组成?  
抽象队列同步器，实现ReentrantReadWriteLock，ReentrantLock、CountDownLatch、Semaphore 
AbstractQueuedSynchronizer
AQS总体上来看是由一个FIFO(先进先出)队列和一个volatile修饰的state属性字段配合组成的
FIFO用来存储线程节点,线程需要排队去获取锁
state属性用来表示资源的状态,如果为0表示空闲,如果资源被每个资源获取到,那么这个资源就会+1,释放 -1 ,当其他的线程试图争夺资源时会检查state的值,如果发现不为0就会放弃争夺

结构： 
	1.volatile语义的state变量
	2.FIFO队列
	
方法：
	tryAcquire()
	tryRelease()
	tryAcquireShared()
	tryReleaseShared()
	isHeldExclusively()
## 19.项目中分布式锁实现的流程图  
加锁: 
1.判断锁是否存在,如果不存在可以直接获取锁,并设置过期的时间,同时自动续期的功能也启用了
2.如果锁存在,需要判断是不是自己的锁,如果是自己的锁,那么可重入次数+1,更新过期时间,自动续期的功能也实现了
3.如果锁不是自己的那么获取锁就失败

解锁: 
1.判断需要解锁的锁是不是自己的锁,如果不是自己的锁那么就抛出异常,恶意的解锁
2.如果是自己的锁,那么将锁的value - 1
3.判断value的值是否为0,如果为0的话,说明解锁成功, 返回true
4.如果value的值不是0,那么说明解锁失败了返回false
## 20.单点登录 购物车模块 订单模块 支付模块 业务流程图(4选2)
单点登录模块:
1.登录的流程
1.根据登录名和密码调用用户管理的远程接口查询用户的信息
2.判断用户是否为空,如果为空,抛出异常,提示登录名或者密码错误
3.如果用户不为空的话,就开始组装载荷,将用户的信息组装到载荷里面,例如username,userId
4.同时为了方式token盗用的情况发生,还需要将用户的登录ip也防止到载荷里面
5.生成jwt类型的token
6.将token设置到cookie里面
7.为了方便页面里面用户名的回显,同时也会将用户的昵称也设置到cookie里面

2.身份认证的流程
1.判断用户请求的路径是否在拦截的路径里面,如果不在拦截的路径里面那么可以直接进行放行
2.如果登录的路径在拦截的路径里面,那么下一步需要获取token
3.如果是同步的请求那么可以从用户的请求的cookie里面获取token,如果是异步的请求那么可以从用户的请求的请求头里面获取token
4.判断token是否为空,如果为空的话,那么将请求重定向到登录的页面,请求结束
5.如果token不为空的话,那么对token进行解析,如果解析的过程中出现异常的话将请求重定向到登录的页面,请求结束
6.如果解析没有问题的话,从解析的结果中获取用户的登录的ip地址,和用户请求的ip地址进行比对,如果比对结果不一致的话,那么将请求重定向到登录的页面,请求结束
7.如果比对的结果没有异常的话,将用户的userId和username设置到请求头里面,方便后续的其他的服务使用
8.结束


购物车模块:
1.新增购物车的模块
首先在拦截器里面根据用户的请求获取到对应的userId和username,同时生成一个随机字符串,如果userId为空的话那么userId就是userKey,如果userId不为空的话,那么userId就是userId
2.根据userId/userkey查询当前用户的购物车
3.判断购物车里面是否包含当前的商品,如果包含的话那么就更新购物车里面商品的数量,如果不包含的话那么就新增购物车同时需要设置商品的实时的价格


2.查询购物车的模块
从拦截器里面获取用户的userId和userkey
1.根据userKey查询未登录用户的购物车,设置购物车里面商品的实时的价格
2.判断用户的userId是否为空, 如果为空的话那么直接返回未登录用户的购物车的数据
3.如果userId不为空的话,那么查询登录用户的购物车的数据,并且合并登录用户和未登录用户的购物车的数据
4.清空登录用户的购物车的数据
5.查询合并后的用户的购物车的数据,并查询实时的价格设置到购物车的商品里面


订单模块: 
结算页面

提交订单创建订单的流程
1.点击购物车结算,跳转到订单结算页面,此时会生成一个orderToken,页面里面保存一份,然后Redis里面也会保存一份
2.点击提交订单的按钮页面跳转,此时会进行反之重复的校验,根据页面里面的orderToken到Redis里面查询,如果可以查询到结果说明是第一次提交,删除Redis里面的orderToken
3.如果查询不到结果说明不是第一次提交,抛出异常提示请勿重复提交
4.验价格,查询购物车里面的所有商品的最新的价格,并计算总价,和页面上传过来的总价进行对比,如果不一致抛出异常提示页面已过期,请刷新重试
5.验库存锁库存
查询并锁定每个商品的数量,这个过程中会获取分布式的锁
确认是否每个商品的库存都锁定成功,如果有一个产品的库存锁定失败了,那么就解锁所有的锁定的库存,并返回商品的锁定信息到前端页面里面
将锁定的仓库的信息缓存到Redis中
为了防止库存锁死的情况发生,此时会将发送延时消息,进行延时解锁的操作

6.创建订单(创建完成后立即发送延时消息启动延时关单)
7.发送异步的消息到MQ里面删除用户的购物车中的选中的商品
