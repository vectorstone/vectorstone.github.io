---
title: java学习笔记
Date: 2023-09-06
tags:
  - 面试
  - 学习笔记
author: Gavin
---
## 深拷贝(深克隆)与浅拷贝的理解
深拷贝和浅拷贝就是指对象的拷贝,一个对象中存在两种类型的属性,一种是基本数据类型,另一种是实例对象的引用
1.浅拷贝是指: 只会拷贝基本数据类型的值,以及实例对象的引用地址,并不会复制一份引用地址所指向的对象,也就是浅拷贝出来的对象,内部的类型属性指向的是同一个对象
2.深拷贝是指,既会拷贝基本数据类型的值,也会针对实例对象的引用地址所指向的对象进行复制,深拷贝出来的对象,内部的类执行指向的不是同一个对象

---

浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。

深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。

## 反射实现的方式有哪些
[40_反射](02%20Java/01JavaSe/40_反射.md#获取到方法区类对象的方式)
类对象:  Person类, User类, Book类, Phone类 这些类我们可以再一次对他们分类，分为 Class类

获取到方法区类对象的方式:
### 1. 类名.class
```java
Class<Person> clz1 = Person.class;
```
### 2. 调用 实例对象.getClass()方法
```java
Class<? extends Person> clz2 = p.getClass();
```
### 3. 调用类加载器的 loadClass()方法
```java
/ ClassLoader classLoader = DownloadClient.class.getClassLoader();
// 在JavaSE里，调用 ClassLoader.getSystemClassLoader()得到的结果就是 AppClassLoader
ClassLoader classLoader = ClassLoader.getSystemClassLoader();
Class<?> clz3 = classLoader.loadClass("com.atguigu.bean.Person");
```
### 4. 调用 Class.forName()静态方法
```java
Class<?> clz4 = Class.forName("com.atguigu.bean.Person");
```
## 项目中哪些场景用到了SQL优化,一定要有实际的使用的场景
## 1.Redis支持哪些数据类型(5个)
redis是一个key-value类型的非关系型数据库，基于内存也可持久化的数据库，相对于关系型数据库（数据主要存在硬盘中），性能高，因此我们一般用redis来做缓存使用；并且redis支持丰富的数据类型，比较容易解决各种问题

| 类型        | 底层数据结构/介绍                                            | 使用场景                                                     |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| string      | 内部结构实现上类似java中的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配.需要注意的是字符串最大长度为512M | 项目中我们主要利用单点登录中的token用string类型来存储；商品详情 |
| hash        | Hash类型第一段数据结构有两种:ziplist(压缩列表),hashtable(哈希表).当field-value长度较短且个数较少时,使用ziplist,否则使用HashTable | Hash类型中的key是string类型，value又是一个map（key-value），针对这种数据特性，比较适合存储对象，在我们项目中由于购物车是用redis来存储的，因此选择redis的散列（hash）来存储； |
| list        | 单键多值,底层是快速双向链表quicklist,在列表元素较少的情况下会使用一块连续的内存存储,结构为ziplist即压缩列表,它将所有的元素紧挨着一起存储,分配的是一块连续的内存.当数据量比较多的时候才会改成quicklist,因为普通的链表需要的附加指针空间太大,浪费空间,eg:列表中存储的只是int类型的数据,结构上还需要两个额外的指针prev与next.redis将链表和ziplist组合起来组成quicklist,即将多个ziplist使用双向指针串起来使用,既满足了快速插入删除性能,又不会出现太大的空间冗余 | List类型是按照插入顺序的字符串链表（双向链表），主要命令是LPOP和RPUSH，能够支持反向查找和遍历，如果使用的话主要存储商品评论列表，key是该商品的ID，value是商品评论信息列表；消息队列 |
| set         | set数据结构是dict字典,字典是用哈希表实现的,java中HashSet内部使用的是HashMap,只不过所有的value都指向同一个对象.Redis中的set也是一样的,他的内部结构也使用hash结构,所有的value都指向同一个内部值 | 可以基于 **Set** 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？ |
| zset        | zset底层使用了两个数据结构 (1)hash,hash的作用就是关联元素value和权重score,保障元素value的唯一性,可以通过元素value找到对应的score的值 (2)跳跃表,跳跃表的目的在于给元素value排序,根据score的范围获取元素列表 | zset（sorted set）类型和set类型基本是一致的，不同的是zset这种类型会给每个元素关联一个**double**类型的分数（score），这样就可以为成员排序，并且插入是有序的。这种数据类型如果使用的话主要用来统计商品的销售排行榜，比如：items:sellsort 10 1001 20 1002 这个代表编号是1001的商品销售数量为10,编号为1002的商品销售数量为20/附件的人 |


## 2.redis为什么是单线程的？单线程的redis为什么读写速度快？
### redis为什么是单线程的
官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了Redis利用队列技术将并发访问变为串行访问
1）绝大部分请求是纯粹的内存操作
2）采用单线程,避免了不必要的上下文切换和竞争条件
### 单线程的redis为什么读写的速度快
1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制
## 3.简述redis持久化方案并描述各自的优缺点？

| 类型              | 介绍                                                         | 具体配置                                                | 优点                                                   | 缺点                                                |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------------ | --------------------------------------------------- |
| RDB               | 默认持久化机制是按照一定的时间将内存中的数据以快照的形式保存到硬盘中 rdb.dump |  | 数据恢复速度快                                         | 可能丢失少量新数据持久化时存储数据效率低            |
| AOF               | 是将Redis的每一次操作都写入到单独的日志文件中，当重启redis会重新从持久化的的日志中恢复数据 文件名为appendonly.aof |  | 持久化效率高 不会丢失数据                              | 恢复数据时效率低aof中记录的所有命令进行重放，效率低 |
| 混合模式(RDB+AOF) | 将RDB和AOF混合一起使用，在使用混合模式时，所有的数据操作也是保存在AOF当中，当进行恢复文件的时候，会将原有的AOF删除，并且将其中的数据全部以快照的形式保存至RDB文件当中 | | 持久化效率高保证数据的安全性不会丢失数据且恢复的速度快 |                                                     |

RDB的配置的方式: 可以设置Redis的自动保存快照 Redis.conf中添加配置,例如:
save 3600 1: 1小时内,有1条数据的改动
save 300 100: 5分钟内,有100条数据改动
save 60 10000: 1分钟内有10000条数据改动

AOF的开启:
默认不开启AOF,需要在配置文件中开启AOF
appendonly yes 默认是no

默认已经开启了混合模式
aof-use-rdb-preamble yew
需要手动的打开AOF:
appendonly yes 默认是no

## 4.聊聊Redis的过期策略及内存淘汰机制？
Redis的过期策略主要有两种：惰性删除和定期删除。惰性删除是指在读取键值对时，先判断该键是否过期，如果过期就删除，否则直接返回。定期删除是指Redis定期检查所有键的过期时间，将其中已经过期的键删除。

内存淘汰机制指的是Redis在内存占用达到限制时，如何选择要删除的键。Redis的内存淘汰机制有6种：

1. noeviction：达到内存限制时，直接返回错误，不会删除任何键值对。
2. allkeys-lru：Redis会遍历所有键值对，选择最近最少使用的键值对进行删除。
3. allkeys-random：Redis会随机选择一些键值对进行删除。
4. volatile-lru：Redis只会删除设置了过期时间的键值对中最近最少使用的那些。
5. volatile-random：Redis只会随机删除设置了过期时间的键值对。
6. volatile-ttl：Redis只会删除设置了过期时间的键值对中，剩余时间最短的那些。
## 5.缓存一致性问题有哪些解决方案，项目中是怎么解决的？
### 写的一致性的问题
#### 双写
不管是先写redis还是先写MySQL都会存在数据不一致的风险的问题,因为Redis不支持回滚
A: 先写Redis,后写MySQL,MySQL遇到异常进行了回滚MySQL里面此时是旧数据,但是Redis里面是新的数据,数据不一致
B: 先写MySQL,最后再写Redis,但是可能因为服务器宕机或者其他的一些因素导致MySQL回滚了,那么MySQL里面是旧的数据,而Redis中是新的数据,数据不一致

结论就是,不管是先写Redis还是先写MySQL都存在数据不一致的问题
#### 失效模式
本质就是Redis不支持回滚的操作,而MySQL支持回滚的操作,导致最终的Redis和MySQL的数据不一致

先删Redis,再写MySQL
单线程的情况下不会存在什么问题, 但是在并发的情况下,在MySQL写入成功之前,有其他的线程在删除Redis后,写入MySQL前查询了缓存,发现没有相应的数据此时就会去数据库查询数据,并且将数据库查询的结果存入到缓存中,所以此时Redis(旧数据),MySQL写入成功后(新数据)   数据不一致的问题

先写MySQL,再删Redis
一样的,在单线程的情况下不会存在任何的问题,但是在并发的情况下就会存在数据不一致的风险
在MySQL写入成功前,删除了Redis,此时别的线程来查询了缓存,发现没有对应的数据,此时会去数据库查询对应的数据,并将查询的结果存入到缓存中, 然后MySQL最后才成功,那么Redis中的是旧的数据,而MySQL中是更新成功的新的数据,数据不一致的问题就又出现了
#### 双删
写入数据库   删除Redis缓存   提交事务  再次删除Redis缓存
再次删除缓存的操作是同步执行的,并发下会影响性能
##### 异步双删
引入消息中间件,将第二次删除Redis缓存的操作交给MQ来完成
##### 延迟双删
由于是异步的原因,所以也可能存在删除了Redis缓存然后MySQL提交的事务才成功,这之间的空档期可能有其他的请求进来查询了数据库并将旧的数据存入了Redis的缓存中,索引第二次的删除采用延时一段时间执行,确保MySQL数据库一定是写入成功的
#### 中间件
例如canal,以及maxwell
利用的是MySQL的主从复制的原理
伪装成MySQL的slave从机,然后监听binlog日志,然后完成数据库的同步的操作

## 6.简述SQL优化
慢查询日志定位较慢的SQL
slow_query_log long_query_time
mysqlslowdump分析慢查询日志

explain: 模拟优化器查看执行计划
通过 id type key key_len row extra(using join buffer / using filesort / using temporary) 出现这三个字段基本上就要优化
type 小于range就要优化(range index all)

适用索引的场景
1.经常查询,排序,分组的字段
2.多表关联字段需要创建索引
3.Distinct字段要创建索引
4.过滤性好的字段也建议创建索引

不适用索引的场景
1.表记录太少
2.过滤性不好的字段(例如性别,男,女就不适合创建索引)
3.写的频率较高的表或者字段
4.还有一条什么

一般性建议:
1.过滤性好的字段创建索引
尽量避免索引失效的情况
	1.1 索引列上有其他的计算,以及有函数,数据类型的转换
	1.2 like查询以%开始
	1.3 != 以及 is not null
	1.4 字符串没有使用单引号
2.单值索引和组合索引选择的时候,优先选择组合索引
	2.1 尽量包含查询中的所有字段
	2.2 复合最左原则
	2.3 不要使用or
	2.4 可能出现范围查询的列,放到组合索引的最后
	2.5  过滤性好的字段最好放到最前面
3.关联优化
	3.1 小表驱动大表
	3.2 被驱动表的关联字段要创建索引
	3.3 inner join字段会自动将小表作为驱动表
	3.4 子查询不要作为被驱动表
	3.5 not in ,not exists
4.排序和分组
	4.1 无过滤不索引
	4.2 顺序错不索引
	4.3 方向反不索引
分组类似于排序,及时没有过滤也可以走索引

5.覆盖索引
不主动追求使用覆盖索引

6.其他
	6.1 字符串需要指定索引的长度
	6.2 select最好不要使用*
	6.3 表记录太多的情况下可以进行分库分表(垂直拆分和水平拆分)
	6.4 读写分离: 提高读的并发的能力(读多写少)

## 7.RabbitMQ的消息模型有哪些？
简单模型 : 一个生产者,一个消费者
worker模型: 一个生产者,多个消费者,消息会被平均分配给多个消费者
publish subscribe 发布订阅模型 : 一个生产者,一个业务交换机,多个消费者,生产者生产的消息会被发给所有的消费者
routing 模型 : 一个生产者生产消息,多个消费者消费消息,交换机会根据队列绑定的routing key 将消息发送给指定的队列,而不是将消息发给所有的消费者
topic模型 : routing key 支持通配符 # 代表任意字符 * 代表一个字符

---

五种消息模型：
  1.简单模型：一个生产者 一个队列 一个消费者
  2.工作模型：一个生产者 一个队列 多个消费者（但是一个队列中的一个消息只能被一个消费者消费）
  3.发布订阅之Fanout：一个生产者 一个交换机 多个队列，每个队列有自己的消费者 （同一个消息进入多个不同的队列，进而被多个消费者同时消费）
  4.路由模型：又称发布订阅之Direct，一个生产者 一个交换机（Direct） 多个队列，每个队列有自己的消费者
  5.主题模型、通配模型、发布订阅之Topic：一个生产者 一个交换机（Topic） 多个队列，每个队列有自己的消费者

## 8.RabbitMQ如何保证消息不丢失？
1.生产者确认确保消息到达MQ(生产者确认机制ACK)
2.消息持久化确保MQ内部消息不丢失
3.消费者确认机制保证消息被消费者正确无误的消费(消费者确认机制ACK)
4.死信队列
5.备份交换机和备份队列
## 9.RabbitMQ消息积压如何处理？
1.使用工作模型,搭建消费者集群,配合能者多劳
开启公平分配(能者多劳)
```properties
# 开启公平分配(能者多劳)  
spring.rabbitmq.listener.simple.prefetch=1
```

2.多线程消费,充分发挥多核CPU优势
默认情况下.一个connection只有一个channel
开启多线程配置,消费者里面
数量根据我们cpu的核心来,cpu有几核就配置几个

```properties
# 开启多线程消费  
spring.rabbitmq.listener.simple.concurrency=6
```

## 10.画图说明线程的生命周期
![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230912190603.png)
（1）新建状态(New) ：线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。  
（2）就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。  
（3）运行状态(Running)：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。  
（4）阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

l  等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。

l  同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。

l  其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join(）等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

（5）死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
## 11.简述线程池原理
线程池底层的源码分析: https://juejin.cn/post/6844904000056197127
### 线程池的执行原理
线程池一开始的时候线程的数量是0
1.判断任务的数量是否超过核心线程的数量,如果没有超过那么创建对应数量的线程数量处理任务
2.如果任务的数量超过了核心线程的数量,那么需要判断队列是否已满,如果队列没满,那么将任务存入阻塞队列中,等待核心线程来处理
3.如果阻塞队列已满,那么还需要进一步的判断任务的数量是否超过了最大的线程的数量,如果没有超过的话,创建对应的线程来处理任务
4.如果任务的数量超过了最大的线程数量,那么会使用拒绝策略来处理不能线程池不能及时处理的任务
5.如果没有新的任务的时候, 线程池就进入了空闲状态
6.最终线程池运行稳定后,会开始收缩,除核心线程数以外的线程会被销毁
## 12.Runnable接口与Callable接口有什么区别？
Runnable应该是比较熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中，该函数没有返回值，不能将结果返回给客户程序。然后使用某个线程去执行runnable即可实现多线程，Thread类在调用start()函数后就是执行的是Runnable的run()函数。

Callable与Runnable的功能大致相似，Callable中有一个call()函数，但是call()函数有返回值。

主要区别：

Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，支持泛型

Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息
## 13.Synchronized和Lock锁的区别
![image-20230303111211678](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/%E9%94%81%E5%AF%B9%E6%AF%94.png)
**基本意义**：Synchronized是Java语言的关键字，因此Synchronized的锁是原生语法层面的互斥，需要JVM来实现。具体是通过对象内部的一个叫做监视器锁（monitor）来实现的。ReentrantLock，字面意思可重入锁，它是JDK1.5之后提供的API层面的互斥锁，锁的功能主要由2个方法完成，即lock()和unlock()。

**易用性**：Synchronized的使用比较方便简洁，由编译器去保证锁的加锁和释放，而ReentrantLock需要手动写代码来加锁和释放锁。  
注意：为避免忘记手工释放锁而造成了死锁，最好在finally中声明释放锁。

**灵活度**：ReentrantLock要优于Synchronized，可以灵活控制在哪个位置加锁和解锁。

性能区别

我们平时写代码的时候用到Java最多的锁是Synchronized，单例模式中看到的锁也是Synchronized。这是为什么呢？除了Synchronized使用方面一些，其实和ReentrantLock对比，性能也丝毫不逊色，这里面说的当然是JDK1.5以后的版本了。

JDK1.6以前的版本没有优化，这时和ReentrantLock比肯定差很多。优化以后的Synchronized引入了包括偏向锁，轻量级锁等，这样就和ReentrantLock性能差不多了。
## 14.说一下对象的内存模型
### Java内存结构：
由Java虚拟机规范定义，描述的是Java程序执行过程中，JVM管理的几个数据区域，不同的区域有不同的功能。

PC寄存器、JAVA虚拟机栈、本地方法栈、堆、方法区。
### Java内存模型（JMM）：
Java内存模型不是真实存在的，它是一个抽象的概念。

Java内存模型是和多线程相关的，描述了一组规范，规范定义了一个线程对共享变量写入时对另一个线程是可见的。

Java多线程之间通过共享内存实现，通信过程中会出现可见性、原子性、顺序性问题，JMM围绕着多线程通信和相关的特性建立的模型，JMM定义了一些语法集，映射到Java语言中就是synchronized、volatile等关键字。

有了Java内存模型，Java并发编程避免了很多问题。
### Java对象模型：
Java对象在JVM中也是有一定的存储结构的，关于Java对象的储存模型称之为Java对象模型。

HotSpot虚拟机中，设计了一种OOP-Klass Model。OOP：普通对象指针；Klass：描述对象实例的具体类型。

每一个Java类，在被JVM加载的时候，JVM会为该给这个类创建一个instanceKlass，用于在JVM层表示该类。在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc，这个对象中包含了对象头和实例数据。


## 15.描述一下synchronized的锁升级过程？
[06_JUC_锁,线程,线程池](02%20Java/10高级/06_JUC_锁,线程,线程池.md#会升级的锁)
synchronized的锁信息保存在对象头中,所以synchronized的锁 等待wait 和 唤醒notify/notifyAll时使用的都是对象的方法

升级的过程
1.如果没有线程访问时,默认不加锁
2.当只有一个线程使用锁时,暂时是一个偏向锁(轻量级的),偏向正在使用锁的线程
3.当竞争访问锁的线程多了以后会升级为自旋锁(while(true){}),获取锁成功的时候执行对应的方法,获取锁失败时会自旋尝试5次获取锁(此时cpu仍然会给该线程分配时间片)
4.当线程获取锁自旋5次没有获取到锁,此时锁会升级为悲观锁(重量级的),获取锁失败的线程会被挂起,挂起的线程不会被cpu分配时间片调度
5.当使用锁的线程释放锁以后,对象会自动唤醒自己头中保存的挂起的线程组,让他们尝试争抢锁,争抢到锁的线程继续执行,失败的线程继续被挂起(线程的唤醒和挂起也是需要损耗系统性能的)
## 16.简述订单是怎么防止重复提交的？
幂等性设计（防重复提交）：跳转到订单那确认页时生成一个OrderToken，页面保存一份、redis保存一份，将来提交订单时，会把该OrderToken提交到后台
			查询redis中是否存在，存在则可以提交订单并删除redis中的orderToken，否则抛出异常（不可重复提交）

## 17.分布式事务理论有哪些？订单中的分布式事务问题是怎么解决的？

### 什么是CAP
#### Consistency一致性
对于数据分布在不同节点上的数据来说,如果在某个节点上更新了数据,那么在其他节点如果都能读取到这个最新的数据,我们就称之为强一致,如果某个节点没有读取到,那就是分布式不一致

一致性是指多副本问题中的数据一致性,可以分为强一致性与弱一致性
强一致性:
在任意时刻,所有节点中的数据都是一样的
例如,对于关系型数据库,要求更新过的数据能被后续的访问都能看到,这就是强一致性

弱一致性:(可能读取数据会有延迟)
数据更新后,如果能容忍后续的访问只能访问到部分或者全部访问不到,这就是弱一致性
最终一致性就属于弱一致性

最终一致性: 
**属于弱一致性的一种特殊的情况,过段时间后数据一直,但是时间长度不一定**

#### Availability可用性
在集群中一部分节点故障后,集群整体是否还能响应客户端的读写请求(要求数据需要备份)
**挂掉一台服务器,依然不影响系统提供完整的服务**
#### Partition tolerance(分区容错)
大多数分布式系统都分布在多个子网络,每个子网络就叫作一个区(partition),分区容错的意思是,**区间通信可能失败,这种情况是无法避免的,要容忍这种情况的发生**

没有哪个分布式系统可以同时保证上面的三点,只能同时保证两点,要么CP,要么AP

**一致性和可用性是相互矛盾的,服务器越多,一致性越差,可用性越高,相反亦然,所以在实际的实践中,要么追求CP,要么追求AP**

CP并发能力可能会弱一些
![](imgs/Pasted%20image%2020230808154020.png)

一般是满足AP的,zookeeper是满足CP的
### 什么是BASE(基于AP的)
BASE强调牺牲高一致性，从而获得可用性，数据**允许在一段时间内的不一致，只要保证最终一致就可以了**

1. Basically Available（**基本可用**）
    基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。 电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。
    
2. Soft status（软状态）
    软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，**允许不同节点间副本同步的延时**就是软状态的体现。mysql replication的异步复制也是一种体现。
    
3. Eventually consistent（最终一致性）
    最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

### 基于BASE理论的一些分布式算法:
Paxos: 兰伯特 拜占庭将军问题(强一致性)

Raft: leader follower candidate(强一致性)
leader选举的过程,分布式一致过程

ZAB协议: Zookeeper Atomic Broadcast,zookeeper源自广播协议(强一致性)
zookeeper分布式协调系统
leader
follower
observer(和follower类似,但是没有投票权)

Gossip协议(弱一致性)
### 主流的分布式事务解决方案
主流的解决方案如下：
1.XA两段提交(低效率)-分布式事务解决方案
2.TCC三段提交(2段,高效率[不推荐(补偿代码)])
3.本地消息(MQ+Table)
4.消息事务+最终一致性(RocketMQ[alibaba])
5.Seata(alibaba) TA
### 订单中的分布式事务的解决
#面试
**提交订单的分布式事务解决方案**: 使用MQ的最终一致性 + 补偿机制,既保证性能又保证可靠性
1.如果验证库存和锁定库存成功,但是订单创建失败,发送消息给MQ解锁库存并标记为无效订单
2.验库存锁库存成功,还没来得及创建订单服务器宕机了,导致库存被锁死: 延时队列 + 死信队列 定时解锁库存
![](imgs/Pasted%20image%2020230904153847.png)

需要解锁库存的场景:
1.请求失败(需要解锁库存)
2.oms执行过程中代码执行异常 (需要解锁库存)
3.响应超时了(可以不用解锁库存)
但是feign远程调用出现的异常无法区分是具体的上面的哪一种的情况,所以我们全部按照解锁库存的操作去解锁,然后订单如果没有创建那不用管,如果订单已经创建了标记为无效的订单
## 18.项目中分布式锁实现的流程图
## 19.单点登录 购物车模块 订单模块 支付模块 业务流程图(4选2)


## 2、RabbitMQ如何保证消息的顺序性(扩展的问题)

消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常。举例：  
比如通过mysql binlog进行两个数据库的数据同步，由于对数据库的数据操作是具有顺序性的，如果操作顺序搞反，就会造成不可估量的错误。比如数据库对一条数据依次进行了 插入->更新->删除操作，这个顺序必须是这样，如果在同步过程中，消息的顺序变成了 删除->插入->更新，那么原本应该被删除的数据，就没有被删除，造成数据的不一致问题。

举例场景：

RabbitMQ：①一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。

![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230912190859.png)

②一个queue对应一个consumer，但是consumer里面进行了多线程消费，这样也会造成消息消费顺序错误。

![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230912190909.png)

解决方案：

①拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230912190928.png)

一个queue对应一个consumer

②或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理

![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230912190940.png)

一个queue对应一个consumer，采用多线程