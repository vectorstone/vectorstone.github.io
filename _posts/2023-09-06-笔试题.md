---
title: java学习笔记
Date: 2023-09-06
tags:
  - 面试
  - 考试
author: Gavin
---
## 1.画图说明jvm的结构
![jvm理解](../../Excalidraw/jvm理解.md)
![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230907223213.png)

ExtClassLoader自定义加载器可以打破双亲委派机制
#思考 为什么类加载器的顺序不可以直接从上往下加载
1.如果有多个自定义的类,直接从上往下找的话会存在不知道如何找哪个类的问题
2.如果直接从上往下加载的话,那么会导致IO的次数变的很多
![](imgs/Recording%2020230912090814.webm)

#思考 
方法区什么时候会OOM
1.方法区太小了
2.一次性加载了大量的类,有太多的依赖需要加载
3.一个tomcat跑了多个项目
4.大量的使用了反射

-Xmn堆的大小  -Xms堆的初始大小 -Xmx最大的大小
一般初始大小和最大的大小设置为一样
复制算法的垃圾回收的总结: 复制  清空  交换

栈帧的四个元素:
本地方法表
私有元素

#思考
堆什么时候会OOM
1.创建了大量的大对象,并没有及时的释放
2.堆大小设置的不合理
3.
## 2.画图说明电商项目架构图
营销,用户,仓库
搜索,支付,登录
![](imgs/王小广-电商架构图-230907.jpg)

电商架构图
客户端:  消费者 平台运营 开发运维
前端交互:  pc/app小程序  管理后台  开发运维
网关服务: nginx两台保持高可用性 , springGateway 负载均衡

商品,购物车,订单   
API层:  营销,用户,仓库
能力层: 搜索,支付,登录
服务层: 
	平台能力: 支付服务,日志服务,物流服务,定位服务,文件服务,短信
	业务能力: 用户模块,支付模块,商品模块,报表模块,评价模块,设置模块,运营模块,资源模块 ,营销模块,结算模块
基础支撑: MySQL集群,Redis基于(带有sentinel集群),ES , OSS ,RabbitMQ

66614
客户端: 消费者  平台运营  开发运维
前端交互: pc站/app小程序  平台运营 开发运维
网关 : nginx + gateway网关服务 负载均衡以及keepalive保证高可用
api层: 商品管理Api 购物车管理api 订单api  
营销,仓库,用户
能力层:  搜索,支付,登录
服务层: 
平台能力: 日志服务, 报表服务, 物流服务,定位服务,文件服务,短信服务
业务能力: 商品模块,支付模块,用户模块,营销模块,评价模块,资源模块,管理模块,结算模块
基础支撑

商品管理api 购物车管理api 订单管理api 营销管理api 用户管理api 仓库管理api
搜索服务 支付服务 单点登录服务

服务层: 
## 3.Feign和OpenFeign的区别？
1.Feign是Netflix开源的,是springCloud第一代远程调用的客户端; OpenFeign是spring开源的是第二代的远程调用的客户端
2.OpenFeign支持SpringMVC注解,使用更加的简洁
3.Feign已经停止维护了,OpenFeign还在频繁的维护



## 4.Eureka、zookeeper和nacos的选型
1.用户友好性   
nacos界面友好,使用方便
Eureka提供了基本的管理的界面,但是不如nacos界面友好
Zookeeper没有提供用户界面

2.功能性  
nacos具备注册中心和配置中心,功能强大
Eureka主要提供的是服务的注册和发现的功能
Zookeeper也提供了注册中心和配置中心的功能

3.社区活跃程度
nacos拥有较大的社区的支持和活跃度,并且还在更新维护
Eureka也拥有较大的社区的支持和活跃度但是已经停止更新维护了
Zookeeper也有较大的社区的支持和应用的场景,但是今年来的活跃度和发展的速度不如nacos和Eureka

4.数据一致性
nacos使用的是Raft的协议,可靠性最高
Eureka异步复制机制来保证数据的一致性
Zookeeper则采用了基于Zab协议的原子广播机制来保证数据的一致性
## 5.谈谈你对AOP的理解并详细说明在项目中的具体应用
面向切面编程的思想,通过动态代理的技术实现了横向增强以及纵向增强,封装了一些非核心业务代码,实现了解耦和以及降低了代码的冗余程度

理解:
1.横向增强和纵向的增强
实现了接口,那么就是横向的增强 JDK的动态代理
没有实现接口,那么就是纵向的增强 cglib的动态代理

2.底层的原理:
使用了动态代理的技术
如果目标类实现了接口,则通过JDK的动态代理技术生成目标类的接口的实现类,这时横向增强
如果目标类没有实现接口,那么通过使用cglib的动态代理的技术生成目标类的子类来实现纵向的增强

3.专有的几个名词
切面类: 封装有一系列通知的方法以及切入点表达式定义的切点
连接点: 可以被增强的方法
切点: 实际被增强的方法
横切关注点: 非核心业务


前置通知: 在目标方法执行前执行的通知
返回通知: 在目标方法正常返回后执行的通知
异常通知: 在目标方法发生异常退出的时候执行的通知
后置通知: 在目标方法执行完成之后(不管是正常返回还是异常的退出)执行的通知
环绕通知: 最强大的一种通知,在目标方法执行前后执行

具体的应用: 
1.给自定义注解赋能实现缓存的功能(之前遇到的因为切入点表达式不正确以及布隆过滤器的原因导致主页的缓存实现的问题)
首先切入点表达式里面定义好只对特定的注解的方法有效
使用环绕通知
根据缓存的前缀+ 目标方法的参数去Redis里面查询是否已经有缓存了,如果有的话直接返回结果
如果没有的话获取分布式锁,然后再次查询缓存,如果能查询的到那么直接返回,如果还是查询不到的话就去数据库里面查询对应的结果,并将结果存放到缓存里面
最后一定要记得解锁

```java
//切面类,用来给自定义注解赋能  
@Aspect  
@Component  
public class GmallAspectCopy {  
    @Autowired  
    StringRedisTemplate stringRedisTemplate;  
    @Autowired  
    RedissonClient redissonClient;  
    @Autowired  
    RBloomFilter rBloomFilter;  
    @Autowired  
    PmsFeign pmsFeign;  
  
    //预留一个位置,切点表达式的重用,这个切点表达式会对service里面的所有的方法起作用  
    // @Pointcut(value = "execution(* com.atguigu.gmall.index.service.*.*(..))")  
  
    //使用下面的这个切点表达是,那么就只对加了@GmallAnnotation注解的方法起作用  
    @Pointcut("@annotation(com.atguigu.gmall.index.annotation.GmallAnnotation)")  
    /* @Pointcut("@annotation(com.atguigu.gmall.index.annotation.GmallCache)")  
    public void gmallCachePoint(){} */    //第一个* 表示权限修饰符和返回值任意  
    //第二个* 表示类名任意  
    //第三个* 表示方法名任意  
    public void pointcutMethod(){}  
    //环绕通知  
    @Around(value = "pointcutMethod()")  
    public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable {  
  
        Object[] args = joinPoint.getArgs();  
        // 获取目标方法的签名  
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();  
  
        // 1.查询缓存  
        //首先查询缓存中是否存在对应的值,如果存在,直接返回结果  
        String key = CommonConst.KEY_PREFIX + StringUtils.join(args,",");  
        String value = stringRedisTemplate.opsForValue().get(key);  
        if(StringUtils.isNotBlank(value)){  
  
            return JSON.parseObject(value,signature.getReturnType());  
        }  
        rBloomFilter = redissonClient.getBloomFilter("index:bf");  
        rBloomFilter.tryInit(2000L,0.03);  
  
        //添加布隆过滤器,避免缓存击穿的问题  
        boolean contains = rBloomFilter.contains(key);  
        if (!contains){  
            //如果查询的key不存在,直接return  
            return null;  
        }  
        // 获取目标方法上的注解(因为需要注解里面的相关的一些的参数)  
        GmallAnnotation annotation = signature.getMethod().getAnnotation(GmallAnnotation.class);  
  
        // 2.获取分布式锁  
        RLock fairLock = redissonClient.getFairLock(annotation.lockPrefix() + StringUtils.join(args, ","));  
        //加锁  
        fairLock.lock();  
  
        //再次查询缓存  
        String afterValue = stringRedisTemplate.opsForValue().get(key);  
        if(StringUtils.isNotBlank(afterValue)){  
            //如果查询出来的结果不为空,则直接返回结果  
            //同理,返回的对象的类型不能写死了,必须通过signature里面获取到对应的类型  
            return JSON.parseArray(afterValue, signature.getReturnType());  
        }  
        try {  
            // 3.执行目标方法查询数据库  
            Object proceed = joinPoint.proceed(args);  
  
            // 4.如果查询的结果不为空,将查询的数据存入缓存中  
            // 设置过期时间  
            Integer expireTime = annotation.expireTime() + annotation.extraExpireTime();  
            stringRedisTemplate.opsForValue().set(key,JSON.toJSONString(proceed),expireTime, TimeUnit.MINUTES);  
  
            return proceed;  
        } finally {  
            // 5.解锁  
            fairLock.unlock();  
        }  
    }  
}
```

2.实现日志的功能
例如什么时间点,哪个模块的哪个方法被执行了,请求的参数是什么,结果是什么,有没有什么异常
## 6.请求熔断和服务降级有什么区别?
![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230906104904.png)
请求熔断: 
**全开:** 请求失败的数量超过一定的比例(默认50%),断路器会切换到全开的状态(open),这时所有的请求都会失败,不会直接发送到后端的服务
**半开:** 断路器在保持开路状态一定的时间后(默认是5秒),自动切换到办开路的状态(half-open)
**全关:** 每隔一段时间(500ms)放行一个请求,判断这个请求的返回情况,如果请求成功则断路器关闭,如果仍然失败,则切换到全开的状态

服务的降级: 
对于某一个操作,我们可以实现一个降级的方案,当请求后端服务出现异常的时候,我们可以快速返回降级方案中的返回值(这个返回值可以来设置默认值也可以来自缓存),避免被下游拖垮

#面试 
如果某个接口此时还没有,但是又需要,怎么办
写一个降级的接口
## 7.画图说明后台管理系统中关于商品表的关系图
![](imgs/Pasted%20image%2020230908091319.png)

![](imgs/王小广-表关系图-230907.jpg)

## 8.简述Hystrix断路器实现熔断原理
理解成开关,开关关闭才能起作用
正常是关闭状态
请求达到阈值的时候,会触发断路器,此时是全开的状态
每隔一段时间放一个请求过去,如果请求成功的话,关闭状态
![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230906104818.png)
## 9.列举Springboot常用注解有哪些(5个)
启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：
@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
@ComponentScan：Spring组件扫描。

@Component  基本注解，标识一个受Spring管理的组件
@Controller    标识为一个表示层的组件
@Service       标识为一个业务层的组件
@Repository    标识为一个持久层的组件
@Autowired     自动装配

@Qualifier("")    具体指定要装配的组件的id值
@RequestMapping()  完成请求映射
@PathVariable    映射请求URL中占位符到请求处理方法的形参

下面的这些可以不用说
@MapperScan 创建mapper接口的动态代理对象
@Autowired 或者 @Resource 装配对应的对象
@FeignClient 创建openFeign远程调用的接口
@Transactional 开启本地事务
@EnableTransactionManagement 开启事务管理器

### springBoot的注解
@ConfigurationProperties
@Configuration
@SpringBootTest

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
@ComponentScan：Spring组件扫描。
### spring的注解
1.初始化注解: @Configuration @Controller @Service @Repository
2.DI上面的注解: @Autowired @Qualifier(如果接口有多个实现类的话,autowired会报错,可以通过Qualifier指定要注入的对象)
3.生命周期: @PostConstruct @PreDestroy(销毁之前执行的)
4.作用域的注解: @Scope(singleTon protoType request session globalSession)

### AOP的注解
@Aspect
还有各种的通知的注解等等
### SpringMVC的注解
@RequestMapping
@GetMapping
等等等
@RequestPara
@PathVirable
@ResponseBody
@CookieValue
@RequestHeader
## 10.项目中分布式锁实现的流程图
![](https://obsidiantuchuanggavin.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020230906150145.png)

下面的增加重入次数之后需要多一个更新过期时间的操作,自动续期的操作也需要放到里面
![](imgs/Pasted%20image%2020230908083230.png)
## 11.简述三次握手和四次挥手
[Day20_网络编程](02%20Java/00讲义/Day20_网络编程.md#3、TCP协议)
发送数据的准备阶段: 三次握手
1.客户端向服务器端发出连接请求,等待服务器确认
2.服务端向客户端回送一个响应,通知客户端收到了连接请求
3.客户端再次向服务端发送确认消息,确认连接

发送数据结束后,释放连接阶段: 四次挥手
1.客户端向服务端提出结束连接,让服务器做最后的准备工作
2.服务器接收到客户端释放连接的请求后,会将最后的数据发送给客户端,并通知上层的应用进程不再接收数据
3.服务器发送完数据后,会给客户端发送一个释放连接的报文,客户端接收到后就可以正式的释放连接了
4.客户端收到服务器最后的释放连接的报文后,要回复一个彻底断开的报文,这样服务器收到后才会彻底的释放连接

三次握手和四次挥手的过程: 
1.客户端向服务器发送建立链接的请求,等待服务器的回应
2.服务器接收到客户端的请求之后回送一个响应,通知客户端收到了建立链接的请求
3.客户端再次向服务端发送一个前确认的消息,确认建立链接

四次挥手的过程: 
1.客户端向服务端提出结束请求,让服务器做最后的准备
2.服务端收到客户端的消息之后,会将最后的数据发送给客户端,并通知上层的应用不在接收数据
3.服务端将最后的数据发送给客户端之后,会给客户端发送一个释放链接的报文,客户端收到这个报文之后就可以断开链接了
4.客户端收到服务端的最后的释放链接的报文之后,还要再向服务端发送一个确认的消息,此时服务器就会彻底的断开链接

## 12.Mybatis中的#{} 与 ${} 有什么区别?
#{}是预编译处理
${}是字符串拼接处理
Mybatis在处理#{}的时候,会将sql中的#{}替换为?号,调用preparedStatement的set方法来进行赋值
Mybatis在处理${}的时候,会将 ${}替换为变量的值
使用#{}可以有效的防止SQL注入,提高系统的安全性

### 峰哥的答案
1.预编译 和 非预编译
2.形式是?   另一个是字符串的拼接
3.防止SQL注入, 不可以防止SQL注入
## 13.项目开发流程是什么?实际开发中使用什么软件管理缺陷?
### 项目开发流程是什么
#### 市场调研(用户的需求)
列出需求列表: 
例如商品列表,需要有分类,模糊查询
商品详情页: 需要有评价
加入购物车: 只需存已登录的购物车,购物车列表的页面
#### 需求文档(通常来自产品经理)
项目背景
具体功能需要有具体的设计
业务流程
表结构设计: 字段 字段类型 字段长度 描述
可以使用工具PowerDesign来进行表设计
#### 文档设计
接口文档
测试用例文档: 操作的前提描述(输入的参数信息),动作描述,期望的效果
#### 开发阶段
任务拆分: leader指定
前端人员写前端的项目
后端人员写数据的接口
#### 联调及测试阶段
1.前后端开发人员进行项目集成
2.需要前后端开发人员先自行的进行测试
3.交付到测试环境,由测试人员进行专业的测试,编写bug文档
4.开发人员配合测试人员进行bug的修复以及升级
#### 运维阶段
开发人员协助运维人员进行项目上线,并编写运维文档

可以使用禅道工具: 从需求 ---> 文档设计 ---> 任务拆分 ---> 测试用例 ---> bug发布 ---> bug修复


市场调研: 
收集用户的需求,例如商品详情页面需要有评论的功能
购物车可以需要有登录状态的购物车已经未登录状态的购物车

需求文档: 
项目背景
功能的设计,具体的功能需要有具体的设计
业务流程
表结构的设计,需要有什么字段,字段的类型已经字段的长度等信息

### 使用什么软件管理缺陷
使用禅道或者测试文档来管理缺陷
## 14.简述Springmvc请求执行流程
1.用户发起请求,请求被dispatcherServlet捕获
2.dispatchServlet将请求交给handlerMapping进行处理,查询具体的handler
3.handlerMapping返回一个handlerExecutionChain对象,里面包含目标hander方法以及interceptor集合
4.dispatchServlet根据获得的handler实现的方式调用合适的handlerAdapter处理用户的请求
5.handlerAdapter调用目标handler方法处理用户的请求
6.handler将处理结果ModelAndView(数据模型 和 视图名称)返回给handlerAdapter
7.handlerAdapter返回ModelAndView对象给dispatcherServlet
8.dispatchServlet根据调用view resolver视图解析器进行解析
9.视图解析器将解析出来的视图view(此时的view不是真正的视图,只是一个逻辑视图)返回给dispatchServlet
10.DispatcherServlet将视图view交给模板引擎进行渲染
11.返回渲染后的真正的视图给dispatcherServlet
12.dispatcherServlet将真正的视图响应给用户
## 15.线程创建方式有哪些?
1.继承Thread类 单继承, 无法捕获异步任务的返回结果集, 无法捕获异步任务的异常信息,线程数量无法控制

2.实现Runnabler接口 无法捕获异步任务的返回结果集, 无法捕获异步任务的异常信息,线程数量无法控制

3.实现Callerable接口 需要搭配futureTask来使用,解决了单继承,无法捕获异步任务的返回结果集以及异常信息的问题,但是线程数量仍然无法控制

4.线程池的方式
解决了上述的所有的问题
## 16.线程池的优势？线程池的7个重要参数？4个拒绝策略？执行原理？
### 线程池的优势
1.降低资源消耗,通过复用已创建的线程降低线程创建和销毁带来的资源的损耗
2.提高响应速度,当任务到达的时候,任务可以不需要等待线程的创建就能立即的执行
3.提高线程的可管理性,线程是稀缺资源,如果无限制的创建不仅会消耗系统的资源,还会降低系统的稳定性,使用线程池可以进行线程统一的分配,调优和监控

### 线程池的7个重要的参数
corePoolSize: 核心线程数(任务会优先的交给核心线程处理)
maximumPoolSize: 最大线程数(线程池最大的可以创建的线程的数量,包括核心线程)
keepAliveTime线程存活时间(除核心线程以外的线程的存活的时间)
TimeUnit线程存活时间单位
Blocking Queue阻塞队列(不能及时分配核心线程处理的任务,会被存入到阻塞队列里面)
Threadfactory线程工厂
rejectedExecutinghandler拒绝策略(线程池不能及时处理的任务会通过处理器拒接或进行其他的操作)
### 线程池的4个拒绝策略
Abortpolicy: 拒绝不能处理的任务,并抛出异常
CallerRunPolicy: 由调用者处理线程池不能及时处理的任务
DiscardPolicy: 丢弃不能及时处理的任务,不会抛出异常
DiscardOldesPolicy: 丢弃等待时间最长的任务
### 线程池的执行原理
线程池一开始的时候线程的数量是0
1.判断任务的数量是否超过核心线程的数量,如果没有超过那么创建对应数量的线程数量处理任务
2.如果任务的数量超过了核心线程的数量,那么需要判断队列是否已满,如果队列没满,那么将任务存入阻塞队列中,等待核心线程来处理
3.如果阻塞队列已满,那么还需要进一步的判断任务的数量是否超过了最大的线程的数量,如果没有超过的话,创建对应的线程来处理任务
4.如果任务的数量超过了最大的线程数量,那么会使用拒绝策略来处理不能线程池不能及时处理的任务
5.如果没有新的任务的时候, 线程池就进入了空闲状态
6.最终线程池运行稳定后,会开始收缩,除核心线程数以外的线程会被销毁
## 17.简述项目中那些地方使用了多线程，使用了那种方式？
### 异步编排(商品详情页的数据)
CompletableFuture异步编排
商品的详情页面设计到大量的远程接口的调用,所以使用了异步编排来提高查询的效率
主要用到的几类方法:

1.任务初始化时
runAsync 初始化一个没有返回结果集的异步任务
supplyAsync 初始化一个有返回结果集的异步任务

2.计算完成时
whenComplete 不管有没有异常都会执行,是同步的方法会阻塞执行
whenCompleteAsync 不管有没有异常都会执行,是异步的方法,不会阻塞执行
exceptionally 只有发生异常的时候才会执行,是同步的方法,会阻塞的执行

3.串行化
thenSupply 接收上一个任务的结果集,给下一个任务自己的结果集
thenAccept 接收上一个任务的结果集,但是没有自己的结果集
thenRun 不接受上一个任务的结果集,也不会返回结果集

4.组合
allOf  只要有任意一个任务执行完成就可以继续往下执行
anyOf 所有的任务执行完成后才能继续的往下执行

### 本地异步声明式异步Async(购物车)
本地异步,性能好,但是不能跨工程,可靠性差
分布式异步(MQ),效率较低,可以跨工程,可靠性好

CompletableFuture和Async都属于是本地异步

1.通过future.get()的方式阻塞获取返回结果集以及异步任务的异常信息
2.通过ListenableFuture.addCallBack(success,failure)监听非阻塞的方式获取异步结果集以及异步的异常的信息
3.如果异步任务的返回结果集是非future类型的,那么可以通过统一的异常处理器来捕获并处理异常
继承SimpleAsyncUncaughtExeceptionHandler这个类实现里面的handleUncaughtExceptionhandler方法即可

### 订单确认页(使用的是CompleteFuture)
为什么使用CompletableFuture而不是SpringTask?
因为任务之间存在依赖关系: 查询spu,查询品牌,查询分类都依赖于 根据skuId查询sku
## 19.Spring Bean的生命周期是什么？
1.调用构造或者是通过工厂的方式创建bean对象
2.给bean对象的属性注入值
3.执行bean后置处理器中的postProcessBeforeinitialization
4.调用初始化方法,进行初始化,初始化方法是通过init-method来指定的
5.执行bean的后置处理器中的postProcessAfterInitialization
6.bean的使用
7.IOC容器关闭时,调用destroy方法销毁bean对象
[[生命周期的演示]]
![](imgs/Pasted%20image%2020230912104304.png)

复杂一点的:
1.bean的实例化: 默认无参构造
2.属性注入: 通过setter方法依赖注入
3.如果实现了BeanNameAware接口,则执行setBeanName方法
4.如果实现了BeanFactoryAware接口,则执行setBeanFactory方法
5.如果实现了ApplicationContextAware接口,则执行setApplicationContext方法
6.执行生命周期方法: @PostConstruct注解所在的方法
7.如果实现InitializingBean接口,则会执行afterPropertiesSet方法
8.bean的使用
9.执行生命周期中方法 @PreDestroy注解所在的方法
10.对象销毁
11.容器关闭
## 20.MyIsam和InnoDB的区别？
InnoDB：支持事务、外键、行级锁，业务表使用，资源开销大
MyIsam：不支持事务,不支持外键,只支持表级锁，系统表使用，资源开销小
