---
layout: post
title: MySQL从入门到精通
subtitle: MySQL从入门到精通
date: 2023-09-15
author: Gavin
header-img: img/post-bg-2015.jpg
catalog: true
tags:
  - 面试
  - MySQL
---
[MySQL中一行数据是怎么存储的](https://xiaolincoding.com/mysql/base/row_format.html#%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E-mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84)
[MySQL从入门到精通 2023-09-15 18.34.14.excalidraw](../../Excalidraw/MySQL从入门到精通%202023-09-15%2018.34.14.excalidraw.md)
#面试 
MySQL的null值会占用空间吗?
MySQL的Compact行格式中会使用Null值列表来标记值为null的列,null值并不会存储在行格式中的真实数据部分
null值列表会占用1字节的空间,当表中的所有的字段都定义成Not Null的时候,行格式中就不会有null值列表,这样可以节省1字节的空间

MySQL怎么知道varchar(n)实际占用数据的大小?
MySQL的compact行格式中会用 变长字段长度列表 存储变长字段实际占用的数据大小

varchar(n)中的n最大的取值为多少?
一行记录直达能存储65535字节的数据,但是这个是包含 变长字段字节数列所占用的字节数 和 Null值列表锁占用的字节数 所以,我们在计算varchar(n)中n的最大值的时候,需要减去这两个列表锁占用的字节数

如果一张表只有一个varchar(n)字段,且允许为null,字符集为ascii 那么 varchar(n)中能最大的取值为65532
如果有多个字段的话,需要保证所有的字段的长度 + 变成字段字节数列表所战友的字节数 + null值列表所占用的字节数 <= 65535

行溢出后,MySQL是怎么处理的?
如果一个数据页存不了一条记录,InnoDb存储引擎会自动的将溢出的数据存放溢出页中
Compact行格式针对行溢出的处理是这样的: 当发生行溢出的时候,在记录的真实数据处只会保存该列的一部分上述,而把剩余的数据放在溢出页中,然后真实数据处使用20字节存储指向溢出页的地址,从而可以找到剩余数据所在的页
Compressed和Dynamic这两种数据格式采用完全的行溢出方式,记录的真实数据处不会存储该列的一部分数据,只存储20个字节的指针来指向溢出页,而实际的数据都存储在溢出页中

算法的时间复杂度
越靠近左上角的越糟糕,右下角的就是我们需要努力的目标
![](imgs/Pasted%20image%2020230915190644.png)

## 索引有哪些,能对这些索引进行一下分类吗


## 联合索引的匹配的原则
联合索引的最左匹配原则,在遇到范围查询(如 > , <)的时候,就会停止匹配,也就是范围查询的字段可以用到联合索引,但是在范围查询字段的后面的字段无法用到联合索引,注意,对于 >=,<= BETWEEN, like前缀匹配的范围查询,并不会停止匹配

## 索引下推
现有联合索引如下: 
```sql
select * from table where a > 1 and b = 2
```
的时候,只有a字段能用到索引,那在联合索引的B+Tree找到第一个满足条件的主键值(ID=2)后,还需要判断其他条件是否满足(看B是否等于2),那么在联合索引里判断?还是回主键索引去判断呢?
- 在MySQL5.6之前,只能从ID2(主键值)开始一个个的回表,到主键索引上找出数据行,在对比b字段值
- 而在MySQL5.6引入的索引下推优化,可以在联合索引遍历过程中,对联合索引中包含的字段先做判断,直接过滤掉不满足条件的记录,减少回表的次数

当你的查询语句的执行计划里面,出现了Extra为Using index condition,那么说明使用了索引下推的优化

## 区分度

实际的开发工作中建立联合索引的时候,要把区分度大的字段排在前面,这样区分度大的字段越有可能被更多的SQL使用到

区分度就是某个字段column不同值的个数 除以 表的总行数

计算区分度的公式: 
![](imgs/Pasted%20image%2020230915222910.png)

索引相关的总结
![](imgs/Pasted%20image%2020230916083317.png)

## B+ Tree和B Tree的主要的区别
- 叶子节点(最底部的节点)才会存放实际数据(索引 + 记录),非叶子节点只会存放索引
- 所有索引都会在叶子节点出现,叶子节点之间构成一个有序的链表
- 非叶子节点的索引也会同时存在在子节点中,并且是在子叶子节点中所有索引的最大(或最小)
- 非叶子节点中有多少个子节点,就有多少个索引

## MySQL单表不要超过2000w行,靠谱吗?
![](imgs/Pasted%20image%2020230923154222.png)

非叶子节点: 
id: 对应页中记录的最小记录id值
页号: 地址是指向对应页的指针
![](imgs/Pasted%20image%2020230923154234.png)

## 单表的建议值是多少
图示的这个数的总的记录数就是4 
(2 ^ (2 - 1)) * 2 = 4
![](imgs/Pasted%20image%2020230923155115.png)

计算的x的最大值为: 15 * 1024 / 12 约等于 1280行